<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bible Connect - è–ç¶“é€£é€£çœ‹</title>
    
    <!-- å¼•å…¥ React å’Œ ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    
    <!-- å¼•å…¥ Babel ç”¨ä¾†è§£æ JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- å¼•å…¥ Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        /* é˜²æ­¢é›™æ“Šé¸å–æ–‡å­—ï¼Œè®“éŠæˆ²é«”é©—æ›´å¥½ */
        body {
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation; /* å„ªåŒ–è§¸æ§é«”é©— */
            overscroll-behavior: none; /* é˜²æ­¢æ‰‹æ©Ÿä¸Šä¸‹æ‹‰å‹•é‡æ•´ */
        }
    </style>
</head>
<!-- 
    Body æ¨£å¼èª¿æ•´ï¼š
    - æ‰‹æ©Ÿé è¨­: h-[100dvh] overflow-hidden (é–å®šä¸€é ï¼Œç„¡æ²è»¸)
    - é›»è…¦ (md): md:h-auto md:min-h-screen md:overflow-y-auto (æ¢å¾©è‡ªå‹•é«˜åº¦ï¼Œå…§å®¹å¤šæ™‚å¯æ²å‹•)
-->
<body class="bg-amber-50 h-[100dvh] w-screen overflow-hidden md:h-auto md:w-auto md:min-h-screen md:overflow-y-auto">
    <div id="root" class="h-full w-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;

        // è¨­å®šé›¢é–‹æŒ‰éˆ•çš„ç›®æ¨™ç¶²å€
        // å¦‚æœç€è¦½å™¨ç„¡æ³•ã€Œå›åˆ°ä¸Šä¸€é ã€ï¼Œå°±æœƒè·³è½‰åˆ°é€™å€‹ç¶²å€
        // æ‚¨å¯ä»¥æ”¹æˆæ‚¨çš„ç¶²ç«™é¦–é ï¼Œä¾‹å¦‚: 'https://www.example.com'
        const FALLBACK_EXIT_URL = 'https://witty-disciple.pages.dev/games/';

        // --- åœ–ç¤ºçµ„ä»¶ ---
        const Book = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>
        );
        const RefreshCw = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M8 16H3v5"/></svg>
        );
        const Trophy = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></svg>
        );
        const Clock = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
        );
        const Zap = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>
        );
        const Lightbulb = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-1 1.5-2.4 1.5-3.8 0-3.2-2.7-5.8-6-5.8S6 4.6 6 7.8c0 1.4.6 2.8 1.5 3.8.8.8 1.3 1.5 1.5 2.5"/><path d="M9 18h6"/><path d="M10 22h4"/></svg>
        );
        const Home = (props) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
        );

        // --- éŠæˆ²è³‡æ–™ ---
        const BIBLE_BOOKS_DATA = [
            { name: "å‰µä¸–è¨˜", icon: "ğŸŒ" }, { name: "å‡ºåŸƒåŠè¨˜", icon: "ğŸŒŠ" }, { name: "åˆ©æœªè¨˜", icon: "ğŸ" }, { name: "æ°‘æ•¸è¨˜", icon: "ğŸ”¢" }, { name: "ç”³å‘½è¨˜", icon: "ğŸ“œ" }, 
            { name: "ç´„æ›¸äºè¨˜", icon: "ğŸº" }, { name: "å£«å¸«è¨˜", icon: "ğŸ’ª" }, { name: "è·¯å¾—è¨˜", icon: "ğŸŒ¾" }, { name: "æ’’æ¯è€³è¨˜ä¸Š", icon: "ğŸ¤´" }, { name: "æ’’æ¯è€³è¨˜ä¸‹", icon: "ğŸ°" }, 
            { name: "åˆ—ç‹ç´€ä¸Š", icon: "ğŸ‘‘" }, { name: "åˆ—ç‹ç´€ä¸‹", icon: "âš”ï¸" }, { name: "æ­·ä»£å¿—ä¸Š", icon: "ğŸ“" }, { name: "æ­·ä»£å¿—ä¸‹", icon: "ğŸ—ï¸" }, 
            { name: "ä»¥æ–¯æ‹‰è¨˜", icon: "ğŸ•" }, 
            { name: "å°¼å¸Œç±³è¨˜", icon: "ğŸ§±" }, 
            { name: "ä»¥æ–¯å¸–è¨˜", icon: "ğŸ‘¸" }, { name: "ç´„ä¼¯è¨˜", icon: "ğŸ¤•" }, { name: "è©©ç¯‡", icon: "ğŸ¼" }, { name: "ç®´è¨€", icon: "ğŸ¦‰" }, 
            { name: "å‚³é“æ›¸", icon: "â˜€ï¸" }, { name: "é›…æ­Œ", icon: "ğŸŒ¹" }, { name: "ä»¥è³½äºæ›¸", icon: "ğŸŒ¿" }, { name: "è€¶åˆ©ç±³æ›¸", icon: "ğŸ˜­" }, { name: "è€¶åˆ©ç±³å“€æ­Œ", icon: "ğŸ’§" }, 
            { name: "ä»¥è¥¿çµæ›¸", icon: "ğŸ’€" }, { name: "ä½†ä»¥ç†æ›¸", icon: "ğŸ¦" }, { name: "ä½•è¥¿é˜¿æ›¸", icon: "ğŸ’" }, { name: "ç´„ç¥æ›¸", icon: "ğŸ¦—" }, { name: "é˜¿æ‘©å¸æ›¸", icon: "ğŸ§º" }, 
            { name: "ä¿„å·´åº•äºæ›¸", icon: "â›°ï¸" }, { name: "ç´„æ‹¿æ›¸", icon: "ğŸ‹" }, { name: "å½Œè¿¦æ›¸", icon: "âš–ï¸" }, { name: "é‚£é´»æ›¸", icon: "ğŸ‘£" }, { name: "å“ˆå·´è°·æ›¸", icon: "ğŸ”­" }, 
            { name: "è¥¿ç•ªé›…æ›¸", icon: "ğŸ•¯ï¸" }, { name: "å“ˆè¯¥æ›¸", icon: "ğŸ " }, { name: "æ’’è¿¦åˆ©äºæ›¸", icon: "ğŸ¦“" }, { name: "ç‘ªæ‹‰åŸºæ›¸", icon: "ğŸ—£ï¸" },
            { name: "é¦¬å¤ªç¦éŸ³", icon: "ğŸ’°" }, { name: "é¦¬å¯ç¦éŸ³", icon: "ğŸ¾" }, { name: "è·¯åŠ ç¦éŸ³", icon: "ğŸ‚" }, { name: "ç´„ç¿°ç¦éŸ³", icon: "ğŸ¦…" }, { name: "ä½¿å¾’è¡Œå‚³", icon: "ğŸ”¥" }, 
            { name: "ç¾…é¦¬æ›¸", icon: "â¤ï¸" }, { name: "å“¥æ—å¤šå‰æ›¸", icon: "â›ª" }, { name: "å“¥æ—å¤šå¾Œæ›¸", icon: "ğŸ›" }, { name: "åŠ æ‹‰å¤ªæ›¸", icon: "â›“ï¸" }, 
            { name: "ä»¥å¼—æ‰€æ›¸", icon: "ğŸ›¡ï¸" }, 
            { name: "è…“ç«‹æ¯”æ›¸", icon: "ğŸ˜ƒ" }, { name: "æ­Œç¾…è¥¿æ›¸", icon: "ğŸ§­" }, { name: "å¸–æ’’ç¾…å°¼è¿¦å‰æ›¸", icon: "ğŸ’¤" }, { name: "å¸–æ’’ç¾…å°¼è¿¦å¾Œæ›¸", icon: "ğŸŒ©ï¸" }, 
            { name: "ææ‘©å¤ªå‰æ›¸", icon: "ğŸ‘”" }, { name: "ææ‘©å¤ªå¾Œæ›¸", icon: "ğŸ" }, { name: "æå¤šæ›¸", icon: "ğŸï¸" }, { name: "è…“åˆ©é–€æ›¸", icon: "ğŸ”“" }, { name: "å¸Œä¼¯ä¾†æ›¸", icon: "ğŸ©¸" }, 
            { name: "é›…å„æ›¸", icon: "ğŸ‘…" }, { name: "å½¼å¾—å‰æ›¸", icon: "ğŸ’" }, { name: "å½¼å¾—å¾Œæ›¸", icon: "âš ï¸" }, { name: "ç´„ç¿°ä¸€æ›¸", icon: "ğŸ’¡" }, { name: "ç´„ç¿°äºŒæ›¸", icon: "ğŸš§" }, 
            { name: "ç´„ç¿°ä¸‰æ›¸", icon: "ğŸ¤" }, { name: "çŒ¶å¤§æ›¸", icon: "ğŸŒŒ" }, { name: "å•Ÿç¤ºéŒ„", icon: "ğŸ—ï¸" }
        ];

        // --- ä¸»éŠæˆ²å…ƒä»¶ ---
        const BibleMatchGame = () => {
            const [cards, setCards] = useState([]);
            const [selectedIndices, setSelectedIndices] = useState([]);
            const [timer, setTimer] = useState(0);
            const [gameWon, setGameWon] = useState(false);
            const [gameActive, setGameActive] = useState(false);
            const [gridCols, setGridCols] = useState(10);
            const [message, setMessage] = useState("");
            const [connectingPath, setConnectingPath] = useState(null);
            const [availableCount, setAvailableCount] = useState(0);

            const gridRef = useRef(null);

            // è™•ç†é›¢é–‹/è¿”å›æŒ‰éˆ•
            const handleExit = () => {
                // å˜—è©¦è¿”å›ä¸Šä¸€é 
                if (window.history.length > 1) {
                    window.history.back();
                } else {
                    // å¦‚æœæ²’æœ‰æ­·å²ç´€éŒ„(ä¾‹å¦‚ç›´æ¥é–‹å•Ÿ)ï¼Œå‰‡è·³è½‰åˆ°é è¨­ç¶²å€
                    window.location.href = FALLBACK_EXIT_URL;
                }
            };

            // éŸ¿æ‡‰å¼ç¶²æ ¼åˆ—æ•¸
            useEffect(() => {
                const handleResize = () => {
                    // å¹³æ¿ (768px) ä»¥ä¸‹ç”¨ 5 æ¬„ (æ‰‹æ©Ÿæ¨¡å¼)ï¼Œä»¥ä¸Šç”¨ 10 æ¬„ (é›»è…¦æ¨¡å¼)
                    if (window.innerWidth < 768) {
                        setGridCols(5);
                    } else {
                        setGridCols(10);
                    }
                };
                handleResize();
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            // -------------------------
            // æ ¸å¿ƒé‚è¼¯ï¼šé€£é€£çœ‹è·¯å¾‘æœå°‹
            // -------------------------
            const getCoords = useCallback((index, cols) => ({
                r: Math.floor(index / cols),
                c: index % cols
            }), []);

            const getIndex = useCallback((r, c, cols) => {
                if (r < 0 || c < 0 || c >= cols) return -1;
                return r * cols + c;
            }, []);

            const isInsideGrid = (r, c, rows, cols) => {
                return r >= 0 && r < rows && c >= 0 && c < cols;
            };

            const findPath = (startIdx, endIdx, currentCards, cols) => {
                const totalCells = currentCards.length;
                const rows = Math.ceil(totalCells / cols);
                const start = getCoords(startIdx, cols);
                const end = getCoords(endIdx, cols);

                const queue = [
                    { r: start.r, c: start.c, turns: 0, dir: 0, path: [{ r: start.r, c: start.c }] }
                ];
                const visited = new Set(); 

                while (queue.length > 0) {
                    const { r, c, turns, dir, path } = queue.shift();
                    if (r === end.r && c === end.c) return path;

                    const moves = [
                        { dr: -1, dc: 0, newDir: 1 }, // Up
                        { dr: 1, dc: 0, newDir: 2 },  // Down
                        { dr: 0, dc: -1, newDir: 3 }, // Left
                        { dr: 0, dc: 1, newDir: 4 }   // Right
                    ];

                    for (let move of moves) {
                        const nr = r + move.dr;
                        const nc = c + move.dc;

                        // å…è¨±èµ°å¤–åœ (-1)
                        if (nr >= -1 && nr <= rows && nc >= -1 && nc <= cols) {
                            const newTurns = (dir !== 0 && dir !== move.newDir) ? turns + 1 : turns;
                            if (newTurns <= 2) {
                                const isTarget = (nr === end.r && nc === end.c);
                                let isPassable = false;
                                if (!isInsideGrid(nr, nc, rows, cols)) {
                                    isPassable = true;
                                } else {
                                    const nextIdx = getIndex(nr, nc, cols);
                                    if (nextIdx >= 0 && nextIdx < currentCards.length) {
                                        isPassable = (currentCards[nextIdx] === null || isTarget);
                                    } else {
                                        isPassable = true; 
                                    }
                                }

                                if (isPassable) {
                                    const stateKey = `${nr},${nc},${move.newDir},${newTurns}`;
                                    if (!visited.has(stateKey)) {
                                        visited.add(stateKey);
                                        queue.push({
                                            r: nr, c: nc, turns: newTurns, dir: move.newDir,
                                            path: [...path, { r: nr, c: nc }]
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
                return null;
            };

            const getAvailableMatchCount = (currentCards, cols) => {
                const indices = currentCards.map((c, i) => c !== null ? i : -1).filter(i => i !== -1);
                const idMap = {};
                indices.forEach(idx => {
                    const id = currentCards[idx].id;
                    if (!idMap[id]) idMap[id] = [];
                    idMap[id].push(idx);
                });

                let count = 0;
                Object.values(idMap).forEach(pair => {
                    if (pair.length === 2) {
                        if (findPath(pair[0], pair[1], currentCards, cols)) count++;
                    }
                });
                return count;
            };

            const shuffleBoard = (currentCards) => {
                const remainingCards = currentCards.filter(c => c !== null);
                const occupiedIndices = currentCards.map((c, i) => c !== null ? i : -1).filter(i => i !== -1);
                const shuffledContent = [...remainingCards].sort(() => 0.5 - Math.random());
                const newCards = [...currentCards];
                occupiedIndices.forEach((pos, i) => { newCards[pos] = shuffledContent[i]; });
                return newCards;
            };

            const initGame = () => {
                const allIndices = Array.from({ length: 66 }, (_, i) => i);
                const shuffledIndices = allIndices.sort(() => 0.5 - Math.random());
                const selectedIndices = shuffledIndices.slice(0, 25);

                let deck = [];
                selectedIndices.forEach((bookIndex) => {
                    const bookData = BIBLE_BOOKS_DATA[bookIndex];
                    const cardData = { book: bookData.name, icon: bookData.icon, id: bookIndex };
                    deck.push({ ...cardData, uniqueId: `${bookIndex}-a` });
                    deck.push({ ...cardData, uniqueId: `${bookIndex}-b` });
                });

                deck.sort(() => 0.5 - Math.random());
                
                let safeDeck = deck;
                let attempts = 0;
                let initialCount = 0;
                do {
                    safeDeck = [...safeDeck].sort(() => 0.5 - Math.random());
                    initialCount = getAvailableMatchCount(safeDeck, gridCols);
                    attempts++;
                } while (initialCount === 0 && attempts < 20);

                setCards(safeDeck);
                setAvailableCount(initialCount);
                setSelectedIndices([]);
                setTimer(0);
                setGameWon(false);
                setGameActive(true);
                setMessage("");
            };

            useEffect(() => { initGame(); }, [gridCols]);

            useEffect(() => {
                let interval = null;
                if (gameActive && !gameWon) {
                    interval = setInterval(() => { setTimer((prev) => prev + 1); }, 1000);
                }
                return () => clearInterval(interval);
            }, [gameActive, gameWon]);

            const handleCardClick = (index) => {
                if (gameWon || !cards[index] || connectingPath) return;

                if (selectedIndices.includes(index)) {
                    setSelectedIndices([]);
                    return;
                }

                const newSelected = [...selectedIndices, index];
                if (newSelected.length === 1) {
                    setSelectedIndices(newSelected);
                } else if (newSelected.length === 2) {
                    setSelectedIndices(newSelected);
                    const idx1 = newSelected[0];
                    const idx2 = newSelected[1];

                    if (cards[idx1].id === cards[idx2].id) {
                        const pathCoords = findPath(idx1, idx2, cards, gridCols);
                        if (pathCoords) {
                            const pathIndices = pathCoords
                                .map(p => getIndex(p.r, p.c, gridCols))
                                .filter(idx => idx !== -1);
                            setConnectingPath(pathIndices);
                            
                            setTimeout(() => {
                                const newCards = [...cards];
                                newCards[idx1] = null;
                                newCards[idx2] = null;
                                
                                const remaining = newCards.filter(c => c !== null).length;
                                if (remaining === 0) {
                                    setGameWon(true);
                                    setGameActive(false);
                                    setCards(newCards);
                                    setAvailableCount(0);
                                } else {
                                    let count = getAvailableMatchCount(newCards, gridCols);
                                    if (count === 0) {
                                        setMessage("ç„¡å¯æ¶ˆé™¤ç‰Œçµ„ï¼Œè‡ªå‹•æ’åˆ—ä¸­...");
                                        let shuffled = newCards;
                                        let attempts = 0;
                                        do {
                                            shuffled = shuffleBoard(shuffled);
                                            count = getAvailableMatchCount(shuffled, gridCols);
                                            attempts++;
                                        } while (count === 0 && attempts < 20);
                                        setCards(shuffled);
                                        setAvailableCount(count);
                                        setTimeout(() => setMessage(""), 1500);
                                    } else {
                                        setCards(newCards);
                                        setAvailableCount(count);
                                    }
                                }
                                setSelectedIndices([]);
                                setConnectingPath(null);
                            }, 300);
                        } else {
                            setMessage("è·¯å¾‘å—é˜»ï¼");
                            setTimeout(() => { setSelectedIndices([]); setMessage(""); }, 500);
                        }
                    } else {
                        setTimeout(() => { setSelectedIndices([]); }, 500);
                    }
                }
            };

            const formatTime = (seconds) => {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
            };

            // ç”¨æ–¼åˆ¤æ–·æ˜¯å¦ç‚ºæ‰‹æ©Ÿç‰ˆçš„è¼”åŠ©è®Šæ•¸
            const isMobile = gridCols === 5;

            return (
                <div className={`flex flex-col items-center py-2 px-2 mx-auto w-full ${isMobile ? 'h-full' : 'h-auto max-w-6xl md:py-6'}`}>
                    
                    {/* æ¨™é¡Œå€ (Header) */}
                    <header className="flex-shrink-0 mb-2 relative w-full flex justify-center items-center">
                        {/* é›¢é–‹æŒ‰éˆ• (çµ•å°å®šä½åœ¨å·¦å´) */}
                        <button 
                            onClick={handleExit}
                            className="absolute left-0 p-2 text-amber-800 hover:bg-amber-100 rounded-full transition-colors active:scale-95"
                            aria-label="å›ä¸Šä¸€é "
                        >
                            <Home className="w-6 h-6 md:w-8 md:h-8" />
                        </button>

                        <div className="text-center">
                            <h1 className="text-xl md:text-3xl font-bold text-amber-800 flex items-center justify-center gap-2">
                                <Book className="w-5 h-5 md:w-8 md:h-8" /> 
                                Bible Connect
                            </h1>
                            <p className="text-amber-700 opacity-80 text-[10px] md:text-sm">
                                è–ç¶“é€£é€£çœ‹
                            </p>
                        </div>
                    </header>

                    {/* æ§åˆ¶åˆ— */}
                    <div className="flex-shrink-0 w-full flex justify-between items-center mb-2 px-3 bg-white p-2 rounded-lg shadow-sm border border-amber-200 z-20">
                        <div className="flex items-center gap-3">
                            <div className="flex items-center gap-1 text-base md:text-lg font-medium text-amber-900">
                                <Clock className="w-4 h-4 md:w-5 md:h-5" />
                                <span>{formatTime(timer)}</span>
                            </div>
                            <div className="flex items-center gap-1 text-xs md:text-sm font-bold text-blue-600 bg-blue-50 px-2 py-1 rounded-full border border-blue-100">
                                <Lightbulb className="w-3 h-3 md:w-4 md:h-4" />
                                <span className="hidden sm:inline">å¯æ¶ˆé™¤:</span>
                                <span>{availableCount} å°</span>
                            </div>
                        </div>
                        
                        <div className="absolute left-1/2 transform -translate-x-1/2 top-12 md:top-auto pointer-events-none w-full text-center z-30">
                            {message && (
                                <span className="bg-amber-600 text-white px-3 py-1 rounded-full text-xs md:text-sm shadow-lg animate-pulse inline-block mx-2">
                                    {message}
                                </span>
                            )}
                        </div>

                        <button 
                            onClick={initGame}
                            className="flex items-center gap-1 bg-amber-600 hover:bg-amber-700 text-white px-3 py-1.5 rounded-lg transition-colors shadow-sm text-xs md:text-sm font-bold active:scale-95"
                        >
                            <RefreshCw className="w-3 h-3 md:w-4 md:h-4" /> 
                            <span className="hidden sm:inline">é‡ä¾†</span>
                        </button>
                    </div>

                    {/* éŠæˆ²å€åŸŸ */}
                    <div className={`w-full relative flex justify-center items-center ${isMobile ? 'flex-1 min-h-0' : 'h-auto'}`}>
                        <div 
                            ref={gridRef}
                            className={`grid gap-1 bg-amber-100/50 rounded-xl relative w-full ${isMobile ? 'h-full' : 'h-auto'}`}
                            style={{
                                gridTemplateColumns: `repeat(${gridCols}, 1fr)`,
                                // æ‰‹æ©Ÿç‰ˆ (5æ¬„): è‡ªå‹•è¨ˆç®—è¡Œé«˜å¡«æ»¿å‰©é¤˜é«˜åº¦ (flex-1)
                                // é›»è…¦ç‰ˆ (10æ¬„): è®“é«˜åº¦è‡ªç„¶æ’é–‹ (ä¸è¨­å®šç‰¹å®šè¡Œé«˜)
                                gridTemplateRows: isMobile ? `repeat(${Math.ceil(50/gridCols)}, 1fr)` : 'none'
                            }}
                        >
                            {cards.map((card, index) => {
                                const isSelected = selectedIndices.includes(index);
                                const isPath = connectingPath && connectingPath.includes(index);
                                
                                if (card === null) {
                                    return (
                                        <div 
                                            key={`empty-${index}`} 
                                            className={`
                                                w-full h-full
                                                rounded-lg border border-transparent
                                                flex justify-center items-center
                                                ${!isMobile ? 'aspect-square' : ''}
                                                ${isPath ? 'bg-yellow-400/30' : ''} 
                                            `}
                                        >
                                            {isPath && <div className="w-2 h-2 bg-yellow-500 rounded-full animate-ping" />}
                                        </div>
                                    );
                                }

                                return (
                                    <div 
                                        key={card.uniqueId}
                                        onClick={() => handleCardClick(index)}
                                        className={`
                                            w-full h-full
                                            flex flex-col justify-center items-center text-center 
                                            border md:border-2 rounded-lg cursor-pointer shadow-sm
                                            transition-all duration-200 relative overflow-hidden
                                            ${!isMobile ? 'aspect-square' : ''} /* é›»è…¦ç‰ˆæ¢å¾©æ­£æ–¹å½¢ï¼Œæ‰‹æ©Ÿç‰ˆå¡«æ»¿é«˜åº¦ */
                                            ${isSelected 
                                                ? "bg-amber-100 border-amber-600 ring-1 ring-amber-400 z-10" 
                                                : "bg-white border-amber-200 hover:border-amber-400 hover:shadow-md"
                                            }
                                            ${isPath ? "bg-green-100 border-green-500 scale-95 opacity-50" : ""}
                                        `}
                                    >
                                        <span className="text-[7vmin] md:text-4xl lg:text-5xl leading-none filter drop-shadow-sm select-none">
                                            {card.icon}
                                        </span>
                                        <span className="text-[2.5vmin] md:text-xs lg:text-sm font-bold leading-tight px-1 break-words select-none mt-1">
                                            {card.book}
                                        </span>
                                        {isPath && <Zap className="absolute text-yellow-500 w-6 h-6 animate-pulse opacity-80" />}
                                    </div>
                                );
                            })}
                        </div>
                        
                        {gameWon && (
                            <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/40 backdrop-blur-sm rounded-xl animate-fade-in">
                                <div className="bg-white p-6 md:p-8 rounded-2xl shadow-2xl flex flex-col items-center text-center max-w-xs md:max-w-sm mx-4 transform animate-bounce-short border-4 border-amber-400">
                                    <div className="w-16 h-16 md:w-20 md:h-20 bg-yellow-100 rounded-full flex items-center justify-center mb-4">
                                        <Trophy className="w-8 h-8 md:w-10 md:h-10 text-yellow-600" />
                                    </div>
                                    <h2 className="text-xl md:text-2xl font-bold text-slate-800 mb-2">å“ˆåˆ©è·¯äºï¼</h2>
                                    <p className="text-sm md:text-base text-slate-600 mb-6">
                                        æ‚¨æˆåŠŸå®Œæˆäº†é€£é€£çœ‹æŒ‘æˆ°ã€‚<br/>
                                        è€—æ™‚ï¼š<span className="font-bold text-amber-600 text-lg">{formatTime(timer)}</span>
                                    </p>
                                    <button 
                                        onClick={initGame}
                                        className="w-full bg-gradient-to-r from-amber-500 to-orange-500 hover:from-amber-600 hover:to-orange-600 text-white font-bold py-3 px-6 rounded-xl shadow-lg transform transition hover:-translate-y-1"
                                    >
                                        å†ç©ä¸€å±€
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>

                    <footer className="flex-shrink-0 mt-2 text-slate-400 text-[10px] text-center">
                        <p>é€£é€£çœ‹è¦å‰‡ï¼šè·¯å¾‘è½‰å½ä¸è¶…éå…©æ¬¡ â€¢ ç„¡è§£è‡ªå‹•é‡æ–°æ’åˆ—</p>
                    </footer>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById("root"));
        root.render(<BibleMatchGame />);
    </script>
</body>
</html>
